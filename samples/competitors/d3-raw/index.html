<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D3 Time Series Chart</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background: #f5f5f5;
      }
      .chart-container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      .axis {
        font-size: 12px;
      }
      .grid-line {
        stroke: #e0e0e0;
        stroke-width: 1;
      }
      .chart-title {
        font-size: 18px;
        font-weight: bold;
        text-anchor: middle;
        fill: #333;
      }
      .brush .selection {
        stroke: #666;
        stroke-width: 1;
        stroke-dasharray: 4, 2;
        fill-opacity: 0.1;
        fill: #666;
      }
      .zoom-overlay {
        fill: none;
        pointer-events: all;
        cursor: grab;
      }
      .zoom-overlay:active {
        cursor: grabbing;
      }
      .controls {
        margin-bottom: 10px;
      }
      .control-button {
        background: #2e86ab;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 8px;
        font-size: 12px;
      }
      .control-button:hover {
        background: #1e5f7a;
      }
      .control-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="chart-container">
      <div class="controls">
        <button class="control-button" onclick="resetZoom()">Reset Zoom</button>
        <button class="control-button" onclick="toggleBrush()" id="brushToggle">
          Enable Brush
        </button>
        <span
          id="selectionInfo"
          style="margin-left: 20px; color: #666; font-size: 12px"
        ></span>
      </div>
      <svg id="chart"></svg>
    </div>

    <script>
      // Segment Tree implementation for range min/max queries
      class SegmentTree {
        constructor(arr) {
          this.n = arr.length;
          this.tree = new Array(4 * this.n);
          this.build(arr, 0, 0, this.n - 1);
        }

        build(arr, node, start, end) {
          if (start === end) {
            this.tree[node] = { min: arr[start], max: arr[start] };
          } else {
            const mid = Math.floor((start + end) / 2);
            this.build(arr, 2 * node + 1, start, mid);
            this.build(arr, 2 * node + 2, mid + 1, end);

            const left = this.tree[2 * node + 1];
            const right = this.tree[2 * node + 2];
            this.tree[node] = {
              min: Math.min(left.min, right.min),
              max: Math.max(left.max, right.max),
            };
          }
        }

        query(node, start, end, l, r) {
          if (r < start || end < l) {
            return { min: Infinity, max: -Infinity };
          }
          if (l <= start && end <= r) {
            return this.tree[node];
          }

          const mid = Math.floor((start + end) / 2);
          const left = this.query(2 * node + 1, start, mid, l, r);
          const right = this.query(2 * node + 2, mid + 1, end, l, r);

          return {
            min: Math.min(left.min, right.min),
            max: Math.max(left.max, right.max),
          };
        }

        getExtent() {
          const result = this.tree[0];
          return [result.min, result.max];
        }

        getRangeExtent(l, r) {
          if (l > r || l < 0 || r >= this.n) return [0, 0];
          const result = this.query(0, 0, this.n - 1, l, r);
          return [result.min, result.max];
        }
      }

      // Generate random walk data
      function generateRandomWalk(numPoints, startValue = 0, volatility = 1) {
        const values = [startValue];
        for (let i = 1; i < numPoints; i++) {
          const change = (Math.random() - 0.5) * 2 * volatility;
          values.push(values[i - 1] + change);
        }
        return values;
      }

      // Chart configuration
      const margin = { top: 40, right: 30, bottom: 60, left: 60 };
      const containerWidth = 800;
      const containerHeight = 550; // Increased height to accommodate x-axis and labels
      const width = containerWidth - margin.left - margin.right;
      const height = containerHeight - margin.top - margin.bottom;

      // Time configuration
      const originTime = new Date("2024-01-01T00:00:00");
      const slotInterval = 60000; // 1 minute in milliseconds
      const numDataPoints = 500;

      // Generate multiple series and build joint segment tree
      const numSeries = 3;
      const series = [];
      const colors = ["#2E86AB", "#A23B72", "#F18F01"];

      // Generate all series data first
      for (let i = 0; i < numSeries; i++) {
        const values = generateRandomWalk(
          numDataPoints,
          Math.random() * 20 - 10,
          2,
        );
        series.push({
          id: i,
          values: values,
          color: colors[i % colors.length],
        });
      }

      // Build joint segment tree with min/max at each time slot across all series
      const jointMinMaxData = [];
      for (let timeIndex = 0; timeIndex < numDataPoints; timeIndex++) {
        let minVal = Infinity;
        let maxVal = -Infinity;

        // Find min/max across all series at this time slot
        series.forEach((s) => {
          const value = s.values[timeIndex];
          minVal = Math.min(minVal, value);
          maxVal = Math.max(maxVal, value);
        });

        jointMinMaxData.push({ min: minVal, max: maxVal });
      }

      // Create single segment tree for joint min/max data
      class JointSegmentTree {
        constructor(jointData) {
          this.n = jointData.length;
          this.tree = new Array(4 * this.n);
          this.build(jointData, 0, 0, this.n - 1);
        }

        build(jointData, node, start, end) {
          if (start === end) {
            this.tree[node] = {
              min: jointData[start].min,
              max: jointData[start].max,
            };
          } else {
            const mid = Math.floor((start + end) / 2);
            this.build(jointData, 2 * node + 1, start, mid);
            this.build(jointData, 2 * node + 2, mid + 1, end);

            const left = this.tree[2 * node + 1];
            const right = this.tree[2 * node + 2];
            this.tree[node] = {
              min: Math.min(left.min, right.min),
              max: Math.max(left.max, right.max),
            };
          }
        }

        query(node, start, end, l, r) {
          if (r < start || end < l) {
            return { min: Infinity, max: -Infinity };
          }
          if (l <= start && end <= r) {
            return this.tree[node];
          }

          const mid = Math.floor((start + end) / 2);
          const left = this.query(2 * node + 1, start, mid, l, r);
          const right = this.query(2 * node + 2, mid + 1, end, l, r);

          return {
            min: Math.min(left.min, right.min),
            max: Math.max(left.max, right.max),
          };
        }

        getExtent() {
          const result = this.tree[0];
          return [result.min, result.max];
        }

        getRangeExtent(l, r) {
          if (l > r || l < 0 || r >= this.n) return [0, 0];
          const result = this.query(0, 0, this.n - 1, l, r);
          return [result.min, result.max];
        }
      }

      const jointSegmentTree = new JointSegmentTree(jointMinMaxData);
      const yExtent = jointSegmentTree.getExtent();

      // Add some padding to y extent
      const yPadding = (yExtent[1] - yExtent[0]) * 0.1;
      const yDomain = [yExtent[0] - yPadding, yExtent[1] + yPadding];

      // Function to calculate visible range extent using joint segment tree
      function getVisibleYExtent(xDomainRange) {
        const startTime = xDomainRange[0].getTime();
        const endTime = xDomainRange[1].getTime();

        // Convert time range to data indices
        const startIndex = Math.max(
          0,
          Math.floor((startTime - originTime.getTime()) / slotInterval),
        );
        const endIndex = Math.min(
          numDataPoints - 1,
          Math.ceil((endTime - originTime.getTime()) / slotInterval),
        );

        if (startIndex >= endIndex) return yDomain;

        // Query joint segment tree for the visible range
        const [globalMin, globalMax] = jointSegmentTree.getRangeExtent(
          startIndex,
          endIndex,
        );

        // Add padding to the visible extent
        const range = globalMax - globalMin;
        const padding = range * 0.1;

        return [globalMin - padding, globalMax + padding];
      }

      // Create SVG with proper sizing
      const svg = d3
        .select("#chart")
        .attr("width", containerWidth)
        .attr("height", containerHeight)
        .style("max-width", "100%")
        .style("height", "auto");

      const g = svg
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      // Create scales
      const xScale = d3
        .scaleTime()
        .domain([
          originTime,
          new Date(originTime.getTime() + (numDataPoints - 1) * slotInterval),
        ])
        .range([0, width]);

      const yScale = d3.scaleLinear().domain(yDomain).range([height, 0]);

      // Store original domains for reset functionality
      const originalXDomain = xScale.domain();
      const originalYDomain = yScale.domain();

      // Current visible range (for calculating normalized coordinates)
      let currentXDomain = [...originalXDomain];
      let currentYDomain = [...originalYDomain];

      // Create axes
      const xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M"));

      const yAxis = d3.axisLeft(yScale);

      // Create axis groups
      const xAxisGroup = g
        .append("g")
        .attr("class", "axis")
        .attr("transform", `translate(0,${height})`);

      const yAxisGroup = g.append("g").attr("class", "axis");

      // Create grid groups
      const gridGroup = g.append("g").attr("class", "grid");

      // Function to update grid lines
      function updateGrid() {
        gridGroup.selectAll(".grid-line").remove();

        gridGroup
          .selectAll(".grid-line.horizontal")
          .data(yScale.ticks(10))
          .enter()
          .append("line")
          .attr("class", "grid-line horizontal")
          .attr("x1", 0)
          .attr("x2", width)
          .attr("y1", (d) => yScale(d))
          .attr("y2", (d) => yScale(d));

        gridGroup
          .selectAll(".grid-line.vertical")
          .data(xScale.ticks(10))
          .enter()
          .append("line")
          .attr("class", "grid-line vertical")
          .attr("x1", (d) => xScale(d))
          .attr("x2", (d) => xScale(d))
          .attr("y1", 0)
          .attr("y2", height);
      }

      // Function to update axes
      function updateAxes() {
        xAxisGroup.call(xAxis);
        yAxisGroup.call(yAxis);
        updateGrid();
      }

      // Initial render of axes and grid
      updateAxes();

      // Add axis labels
      g.append("text")
        .attr("class", "axis-label")
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", height + 50)
        .text("Time");

      g.append("text")
        .attr("class", "axis-label")
        .attr("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -40)
        .text("Value");

      // Add chart title
      svg
        .append("text")
        .attr("class", "chart-title")
        .attr("x", containerWidth / 2)
        .attr("y", 25)
        .text("Random Walk Time Series");

      // Create line generator without x/y accessors
      const line = d3.line().curve(d3.curveLinear);

      // Create clipping path
      svg
        .append("defs")
        .append("clipPath")
        .attr("id", "chart-clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height);

      // Create lines container with clipping
      const linesContainer = g
        .append("g")
        .attr("class", "lines")
        .attr("clip-path", "url(#chart-clip)");

      // Function to get normalized coordinates for current domain
      function getNormalizedCoordinates(seriesValues) {
        return seriesValues.map((value, index) => {
          const timeValue = originTime.getTime() + index * slotInterval;
          const normalizedX =
            (timeValue - currentXDomain[0].getTime()) /
            (currentXDomain[1].getTime() - currentXDomain[0].getTime());
          const normalizedY =
            (value - currentYDomain[0]) /
            (currentYDomain[1] - currentYDomain[0]);
          return [normalizedX, normalizedY];
        });
      }

      // Function to update lines based on current domain
      function updateLines() {
        const lineGroups = linesContainer.selectAll(".line-group").data(series);

        const lineGroupEnter = lineGroups
          .enter()
          .append("g")
          .attr("class", "line-group");

        lineGroupEnter
          .append("g")
          .attr("class", "scaled-group")
          .attr("transform", `scale(${width}, ${-height}) translate(0, -1)`)
          .append("path")
          .attr("fill", "none")
          .attr("stroke-width", 2)
          .attr("vector-effect", "non-scaling-stroke");

        // Update all line groups
        linesContainer.selectAll(".line-group").each(function (d) {
          const pathData = getNormalizedCoordinates(d.values);

          d3.select(this)
            .select("path")
            .datum(pathData)
            .attr("d", line)
            .attr("stroke", d.color);
        });
      }

      // Initial render of lines
      updateLines();

      // Add legend
      const legend = g
        .append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width - 100}, 20)`);

      series.forEach((s, i) => {
        const legendItem = legend
          .append("g")
          .attr("transform", `translate(0, ${i * 20})`);

        legendItem
          .append("line")
          .attr("x1", 0)
          .attr("x2", 15)
          .attr("y1", 0)
          .attr("y2", 0)
          .attr("stroke", s.color)
          .attr("stroke-width", 2);

        legendItem
          .append("text")
          .attr("x", 20)
          .attr("y", 0)
          .attr("dy", "0.35em")
          .attr("font-size", "12px")
          .text(`Series ${s.id + 1}`);
      });

      // Create zoom behavior with constrained extent
      const zoom = d3
        .zoom()
        .scaleExtent([1, 50])
        .translateExtent([
          [0, 0],
          [width, height],
        ])
        .extent([
          [0, 0],
          [width, height],
        ])
        .on("zoom", function (event) {
          const transform = event.transform;

          // Calculate potential new X domain
          const potentialXDomain = transform
            .rescaleX(d3.scaleTime().domain(originalXDomain).range([0, width]))
            .domain();

          // Constrain X domain to data boundaries
          const dataStartTime = originalXDomain[0];
          const dataEndTime = originalXDomain[1];

          let constrainedXDomain = [...potentialXDomain];

          // Prevent zooming out beyond original data range
          if (constrainedXDomain[0] < dataStartTime) {
            const shift =
              dataStartTime.getTime() - constrainedXDomain[0].getTime();
            constrainedXDomain[0] = dataStartTime;
            constrainedXDomain[1] = new Date(
              constrainedXDomain[1].getTime() + shift,
            );
          }

          if (constrainedXDomain[1] > dataEndTime) {
            const shift =
              constrainedXDomain[1].getTime() - dataEndTime.getTime();
            constrainedXDomain[1] = dataEndTime;
            constrainedXDomain[0] = new Date(
              constrainedXDomain[0].getTime() - shift,
            );
          }

          // Ensure we don't exceed original bounds after adjustment
          if (constrainedXDomain[0] < dataStartTime) {
            constrainedXDomain[0] = dataStartTime;
          }
          if (constrainedXDomain[1] > dataEndTime) {
            constrainedXDomain[1] = dataEndTime;
          }

          // Calculate Y domain using joint segment tree for constrained range
          const newYDomain = getVisibleYExtent(constrainedXDomain);

          // Update current domains
          currentXDomain = constrainedXDomain;
          currentYDomain = newYDomain;

          // Update scales
          xScale.domain(constrainedXDomain);
          yScale.domain(newYDomain);

          // Re-render everything
          updateAxes();
          updateLines();
        });

      // Create brush
      const brush = d3
        .brushX()
        .extent([
          [0, 0],
          [width, height],
        ])
        .on("end", function (event) {
          if (!event.selection) return;

          const [x0, x1] = event.selection;
          const timeRange = [xScale.invert(x0), xScale.invert(x1)];

          // Constrain selection to data boundaries
          const dataStartTime = originalXDomain[0];
          const dataEndTime = originalXDomain[1];

          const constrainedTimeRange = [
            new Date(Math.max(timeRange[0].getTime(), dataStartTime.getTime())),
            new Date(Math.min(timeRange[1].getTime(), dataEndTime.getTime())),
          ];

          // Only proceed if we have a valid time range
          if (constrainedTimeRange[0] >= constrainedTimeRange[1]) {
            brushGroup.call(brush.clear);
            return;
          }

          // Update selection info
          const startTime = d3.timeFormat("%H:%M:%S")(constrainedTimeRange[0]);
          const endTime = d3.timeFormat("%H:%M:%S")(constrainedTimeRange[1]);
          document.getElementById("selectionInfo").textContent =
            `Selection: ${startTime} - ${endTime}`;

          // Calculate Y extent for the constrained range using segment trees
          const newXDomain = constrainedTimeRange;
          const newYDomain = getVisibleYExtent(newXDomain);

          // Update domains
          currentXDomain = newXDomain;
          currentYDomain = newYDomain;
          xScale.domain(newXDomain);
          yScale.domain(newYDomain);

          updateAxes();
          updateLines();

          // Clear brush
          brushGroup.call(brush.clear);
        });

      // Add zoom overlay (positioned correctly within the chart area)
      const zoomOverlay = g
        .append("rect")
        .attr("class", "zoom-overlay")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", height)
        .style("fill", "none")
        .style("pointer-events", "all")
        .call(zoom);

      // Add brush group (initially hidden)
      const brushGroup = g
        .append("g")
        .attr("class", "brush")
        .style("display", "none")
        .call(brush);

      // Control functions
      let brushEnabled = false;

      window.resetZoom = function () {
        currentXDomain = [...originalXDomain];
        currentYDomain = [...originalYDomain];
        xScale.domain(originalXDomain);
        yScale.domain(originalYDomain);

        updateAxes();
        updateLines();

        // Reset zoom transform
        svg.call(zoom.transform, d3.zoomIdentity);

        // Clear selection info
        document.getElementById("selectionInfo").textContent = "";
      };

      window.toggleBrush = function () {
        brushEnabled = !brushEnabled;
        const button = document.getElementById("brushToggle");

        if (brushEnabled) {
          brushGroup.style("display", null);
          zoomOverlay
            .style("pointer-events", "none")
            .style("cursor", "default");
          button.textContent = "Disable Brush";
        } else {
          brushGroup.style("display", "none");
          zoomOverlay.style("pointer-events", "all").style("cursor", "grab");
          button.textContent = "Enable Brush";
          document.getElementById("selectionInfo").textContent = "";
        }
      };

      console.log("Chart generated with:");
      console.log(`- ${numDataPoints} data points per series`);
      console.log(`- ${numSeries} series`);
      console.log(
        `- Y extent calculated using segment tree: [${yExtent[0].toFixed(2)}, ${yExtent[1].toFixed(2)}]`,
      );
      console.log(
        `- Time slots: ${slotInterval}ms intervals starting from ${originTime}`,
      );
    </script>
  </body>
</html>
